/*
 *
 *  * Copyright 2024 New Relic Corporation. All rights reserved.
 *  * SPDX-License-Identifier: Apache-2.0
 *
 */

package com.newrelic.utils;

import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Transaction;
import software.amazon.awssdk.services.bedrockruntime.model.InvokeModelRequest;
import software.amazon.awssdk.services.bedrockruntime.model.InvokeModelResponse;

import java.util.HashMap;
import java.util.Map;

public class BedrockRuntimeUtil {
    private static final String VENDOR = "bedrock";
    private static final String INGEST_SOURCE = "Java";
    private static final String TRACE_ID = "trace.id";
    private static final String SPAN_ID = "span.id";

    // LLM event types
    private static final String LLM_EMBEDDING = "LlmEmbedding";
    private static final String LLM_CHAT_COMPLETION_SUMMARY = "LlmChatCompletionSummary";
    private static final String LLM_CHAT_COMPLETION_MESSAGE = "LlmChatCompletionMessage";

    /**
     * This needs to be incremented for every invocation of the Bedrock SDK.
     * <p>
     * The metric generated triggers the creation of a tag which gates the AI Response UI. The
     * tag lives for 27 hours so if this metric isn't repeatedly sent the tag will disappear and
     * the UI will be hidden.
     */
    public static void incrementBedrockInstrumentedMetric() {
        NewRelic.incrementCounter("Java/ML/Bedrock/2.20");
    }

    public static void setLlmOperationMetricName(Transaction txn, String operationType) {
        txn.getTracedMethod().setMetricName("Llm", operationType, "Bedrock", "invokeModel");
    }

    // TODO add event builders??? Avoid adding null/empty attributes?

    public static void reportLlmEmbeddingEvent(Transaction txn, Map<String, String> linkingMetadata, InvokeModelRequestWrapper invokeModelRequestWrapper,
            InvokeModelResponseWrapper invokeModelResponseWrapper) {
        // TODO available data
        String stopSequences = invokeModelRequestWrapper.parseStopSequences();
        String maxTokensToSample = invokeModelRequestWrapper.parseMaxTokensToSample();
        String temperature = invokeModelRequestWrapper.parseTemperature();
        String prompt = invokeModelRequestWrapper.parsePrompt();

        String completion = invokeModelResponseWrapper.parseCompletion();
        String stop = invokeModelResponseWrapper.parseStop();
        String stopReason = invokeModelResponseWrapper.parseStopReason();
        String inputTokenCount = invokeModelResponseWrapper.getInputTokenCount();
        String outputTokenCount = invokeModelResponseWrapper.getOutputTokenCount();
        String invocationLatency = invokeModelResponseWrapper.getInvocationLatency();
        String operationType = invokeModelResponseWrapper.getOperationType();

        // TODO is it possible to do something like this to call getUserAttributes?
        //  see com.newrelic.agent.bridge.Transaction

        Map<String, String> eventAttributes = new HashMap<>();
        eventAttributes.put("id", ""); // TODO ID in the format response_id-sequence or a UUID generated by the agent if no response ID is returned by the LLM
        eventAttributes.put("request_id", invokeModelResponseWrapper.getAmznRequestId());
        eventAttributes.put("span_id", getSpanId(linkingMetadata));
        eventAttributes.put("transaction_id", ""); // TODO figure out how to get this from agent
        eventAttributes.put("trace_id", getTraceId(linkingMetadata));
        eventAttributes.put("input", ""); // TODO figure out how to get this
        eventAttributes.put("api_key_last_four_digits", ""); // TODO Final digits of API key formatted as: sk-{last_four_digits_of_api_key}
        eventAttributes.put("request.model", invokeModelRequestWrapper.getModelId());
        eventAttributes.put("response.model", ""); // TODO Model name returned in the response (can differ from request.model)
        eventAttributes.put("response.organization", ""); // TODO Organization ID returned in the response or response headers
        eventAttributes.put("response.usage.total_tokens", "");
        eventAttributes.put("response.usage.prompt_tokens", "");
        eventAttributes.put("vendor", getVendor());
        eventAttributes.put("ingest_source", getIngestSource());
        eventAttributes.put("duration", "");
        eventAttributes.put("error", "");
//        eventAttributes.put("llm.<user_defined_metadata>", "");

        NewRelic.getAgent().getInsights().recordCustomEvent(LLM_EMBEDDING, eventAttributes);
    }

    public static void reportLlmChatCompletionSummaryEvent(Transaction txn, Map<String, String> linkingMetadata,
            InvokeModelRequestWrapper invokeModelRequestWrapper, InvokeModelResponseWrapper invokeModelResponseWrapper) {
        // TODO available data
        String stopSequences = invokeModelRequestWrapper.parseStopSequences();
        String maxTokensToSample = invokeModelRequestWrapper.parseMaxTokensToSample();
        String temperature = invokeModelRequestWrapper.parseTemperature();
        String prompt = invokeModelRequestWrapper.parsePrompt();

        String completion = invokeModelResponseWrapper.parseCompletion();
        String stop = invokeModelResponseWrapper.parseStop();
        String stopReason = invokeModelResponseWrapper.parseStopReason();
        String inputTokenCount = invokeModelResponseWrapper.getInputTokenCount();
        String outputTokenCount = invokeModelResponseWrapper.getOutputTokenCount();
        String invocationLatency = invokeModelResponseWrapper.getInvocationLatency();
        String operationType = invokeModelResponseWrapper.getOperationType();

        // TODO is it possible to do something like this to call getUserAttributes?
        //  see com.newrelic.agent.bridge.Transaction

        Map<String, String> eventAttributes = new HashMap<>();
        eventAttributes.put("id", ""); // TODO ID in the format response_id-sequence or a UUID generated by the agent if no response ID is returned by the LLM
        eventAttributes.put("request_id", invokeModelResponseWrapper.getAmznRequestId());
        eventAttributes.put("span_id", getSpanId(linkingMetadata));
        eventAttributes.put("transaction_id", ""); // TODO figure out how to get this from agent
        eventAttributes.put("trace_id", getTraceId(linkingMetadata));
        eventAttributes.put("api_key_last_four_digits", ""); // TODO Final digits of API key formatted as: sk-{last_four_digits_of_api_key}
        eventAttributes.put("request.temperature", invokeModelRequestWrapper.parseTemperature());
        eventAttributes.put("request.max_tokens", invokeModelRequestWrapper.parseMaxTokensToSample());
        eventAttributes.put("request.model", invokeModelRequestWrapper.getModelId());
        eventAttributes.put("response.model", ""); // TODO Model name returned in the response (can differ from request.model)
        eventAttributes.put("response.organization", ""); // TODO Organization ID returned in the response or response headers
        eventAttributes.put("response.number_of_messages", "");
        eventAttributes.put("response.usage.total_tokens", "");
        eventAttributes.put("response.usage.prompt_tokens", "");
        eventAttributes.put("response.usage.completion_tokens", "");
        eventAttributes.put("response.choices.finish_reason", "");
        eventAttributes.put("vendor", getVendor());
        eventAttributes.put("ingest_source", getIngestSource());
        eventAttributes.put("duration", "");
        eventAttributes.put("error", "");
//        eventAttributes.put("llm.<user_defined_metadata>", "");
        eventAttributes.put("conversation_id", ""); // TODO Optional attribute that can be added to a transaction by a customer via add_custom_attribute API

        NewRelic.getAgent().getInsights().recordCustomEvent(LLM_CHAT_COMPLETION_SUMMARY, eventAttributes);
    }

    public static void reportLlmChatCompletionMessageEvent(Transaction txn, Map<String, String> linkingMetadata,
            InvokeModelRequestWrapper invokeModelRequestWrapper, InvokeModelResponseWrapper invokeModelResponseWrapper) {
        // TODO available data
        String stopSequences = invokeModelRequestWrapper.parseStopSequences();
        String maxTokensToSample = invokeModelRequestWrapper.parseMaxTokensToSample();
        String temperature = invokeModelRequestWrapper.parseTemperature();
        String prompt = invokeModelRequestWrapper.parsePrompt();

        String completion = invokeModelResponseWrapper.parseCompletion();
        String stop = invokeModelResponseWrapper.parseStop();
        String stopReason = invokeModelResponseWrapper.parseStopReason();
        String inputTokenCount = invokeModelResponseWrapper.getInputTokenCount();
        String outputTokenCount = invokeModelResponseWrapper.getOutputTokenCount();
        String invocationLatency = invokeModelResponseWrapper.getInvocationLatency();
        String operationType = invokeModelResponseWrapper.getOperationType();

        // TODO is it possible to do something like this to call getUserAttributes?
        //  see com.newrelic.agent.bridge.Transaction

        Map<String, String> eventAttributes = new HashMap<>();
        eventAttributes.put("id", ""); // TODO ID in the format response_id-sequence or a UUID generated by the agent if no response ID is returned by the LLM
        eventAttributes.put("request_id", invokeModelResponseWrapper.getAmznRequestId());
        eventAttributes.put("span_id", getSpanId(linkingMetadata));
        eventAttributes.put("transaction_id", ""); // TODO figure out how to get this from agent
        eventAttributes.put("trace_id", getTraceId(linkingMetadata));
        eventAttributes.put("conversation_id", ""); // TODO Optional attribute that can be added to a transaction by a customer via add_custom_attribute API
        eventAttributes.put("api_key_last_four_digits", ""); // TODO Final digits of API key formatted as: sk-{last_four_digits_of_api_key}
        eventAttributes.put("response.model", ""); // TODO Model name returned in the response (can differ from request.model)
        eventAttributes.put("vendor", getVendor());
        eventAttributes.put("ingest_source", getIngestSource());
        eventAttributes.put("content", invokeModelRequestWrapper.parsePrompt());
        eventAttributes.put("role", ""); // TODO Role of the message creator (ex: system, assistant, user)
        eventAttributes.put("sequence", "");
        eventAttributes.put("completion_id", "");
        eventAttributes.put("is_response", "");
//        eventAttributes.put("llm.<user_defined_metadata>", "");

        NewRelic.getAgent().getInsights().recordCustomEvent(LLM_CHAT_COMPLETION_MESSAGE, eventAttributes);
    }

    public static void debugLoggingForDevelopment(Transaction transaction, InvokeModelRequest invokeModelRequest, InvokeModelResponse invokeModelResponse) {
        System.out.println();
        System.out.println("Request: " + invokeModelRequest);
        System.out.println("Request Body (UTF8 String): " + invokeModelRequest.body().asUtf8String());

        System.out.println();
        System.out.println("Response: " + invokeModelResponse);
        System.out.println("Response Body (UTF8 String): " + invokeModelResponse.body().asUtf8String());
        System.out.println("Response Metadata: " + invokeModelResponse.responseMetadata());
        System.out.println("Response Metadata Request ID: " + invokeModelResponse.responseMetadata().requestId());
        System.out.println("Response SdkHttpResponse Status Code: " + invokeModelResponse.sdkHttpResponse().statusCode());
        System.out.println("Response SdkHttpResponse Status Text: " + invokeModelResponse.sdkHttpResponse().statusText());
        System.out.println("Response SdkHttpResponse Is Successful: " + invokeModelResponse.sdkHttpResponse().isSuccessful());
        System.out.println();
    }

    // ========================= AGENT DATA ================================
    // Lowercased name of vendor (bedrock or openAI)
    public static String getVendor() {
        return VENDOR;
    }

    // Name of the language agent (ex: Python, Node)
    public static String getIngestSource() {
        return INGEST_SOURCE;
    }

    // GUID associated with the active trace
    public static String getSpanId(Map<String, String> linkingMetadata) {
        return linkingMetadata.get(SPAN_ID);
    }

    // ID of the current trace
    public static String getTraceId(Map<String, String> linkingMetadata) {
        return linkingMetadata.get(TRACE_ID);
    }

    // ID of the active transaction
    public String getTransactionId() {
        // FIXME not sure that this is accessible in an instrumentation module
        //  might need to add this to events withing the record_event API logic
        //  Sounds like we need to expose this on the public Transaction API
        return "";
    }

    // Optional metadata attributes that can be added to a transaction by a customer via add_custom_attribute API
    public String getLlmUserDefinedMetadata() {
        // FIXME hmm where can user attributes actually be accessed from????? AgentBridge??? Tracer???
        //  If we create a new AI event type with it's own endpoint this would be inherited from from AnalyticsEvent
        return "";
    }

    // Optional attribute that can be added to a transaction by a customer via add_custom_attribute API
    public String getLlmConversationId() {
        // FIXME hmm where can user attributes actually be accessed from????? AgentBridge??? Tracer???
        //  If we create a new AI event type with it's own endpoint this would be inherited from from AnalyticsEvent
        return "";
    }

    // Boolean set to True if a message is the result of a chat completion and not an input message
    public String getIsResponse(InvokeModelResponse invokeModelResponse) {
        // TODO Should this return a boolean or string??
        return "";
    }
}
